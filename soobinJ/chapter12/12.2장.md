# 12장 타입스크립트 프로젝트 관리

## 12.2 스크립트와 설정 파일 활용하기

### 1. 스크립트 활용하기

- 실시간으로 타입을 검사
  - 일반적으로 TS 프로젝트에서는 에디터가 타입 에러를 감지해줌
  - 하지만, 성능이 떨어지거나 프로젝트 규모가 커지면 에디터가 타입 에러를 알려주는 속도가 느려짐
  - 에디터에서는 에러가 없다고 확인했지만 husky에 의해 발견되는 경우도 존재
  - 스크립트를 사용해 실시간 에러 확인 가능
    - `yarn tsc --noEmit --incremental -w`
    - 프로젝트의 tsc를 실행함
    - noEmit: 자바스크립트로 된 출력 파일을 생성하지 않도록 설정
    - incremental: 증분 컴파일을 활성화하여 컴파일 시간을 단축
      - 증분 컴파일: 변경 사항이 있는 부분만을 컴파일 하는 것
    - w: 파일 변경 사항을 모니터링함
    - 파일이 변경될 때마다 tsc가 실행되어 어디에 타입 에러가 발생했는지 실시간 추적 가능
- 타입 커버리지 확인
  - 프로젝트의 모든 부분이 타입스크립트 통제하에 돌아가고 있는지를 정량적으로 판단하기 위해 사용
  - `npx type-coverage --detail`
  - 타입 커버리지와 any를 사용하고 있는 변수의 위치가 나타남
  - 타입스크립트로 마이그레이션 중인 프로젝트나 레거시 코드가 많은 프로젝트를 다룰 때 도움이 됨
  - 정량적인 지표를 얻을 수 있음

### 2. 설정 파일 활용하기

- 타입스크립트 컴파일 속도 높이기
  - tsconfig의 incremental 속성을 활용하여 타입스크립트의 컴파일 속도를 높일 수 있음
  - 증분 컴파일이 활성화됨 -> 변경된 부분만 컴파일 하여 컴파일타임을 줄일 수 있음
  - tsconfig 파일에 설정 추가
    ```ts
    {
        "compilerOptions": {
            ...
            incremental: true
        }
    }
    ```
  - 스크립트 활용
    - `yarn tsc --noEmit --incremntal -diagnostic`

### 3. 에디터 활용하기

- 에디터에서 타입스크립트 서버 재시작하기
  - 정의된 타입이 있는 객체인데도 임포트되지 않거나 자동 완성 기능이 동작하지 않는 경우 종종 발생
  - 이런 경우 타입스크립트 서버를 재실행
  - `command + shift + P`

## 12.3 타입스크립트 마이그레이션

### 1. 타입스크립트 마이그레이션의 필요성

- 도입 결정 -> 반드시 기존 프로젝트를 타입스크립트로 마이그레이션해야만 하는건 아님
- 기존 코드의 구조적인 한계 존재 -> 해당 상황에서 변환하는 것은 비즈니스 로직에 맞지 않는 인터페이스만 추가하는 작업일 수 있음
- 상황에 따라 비즈니스 요구 사항의 변화를 반영할 수 있는 새로운 설계를 기반으로 타입을 작성하는게 효율적일 수 있음

### 2. 점진적인 마이그레이션

- 전체 마이그레이션을 완료할 수 없음 -> 작은 부분부터 점차 범위를 넓혀가며 마이그레이션을 진행함
- 작은 부분부터 마이그레이션 시작 -> 진입 장벽이 낮아지고 프로젝트의 전반적인 동작을 안정적으로 유지 가능
- allowJS: true, noImplicityAny: false를 설정한 채 무기한 마이그레이션을 미루는 것은 지양해야 함

### 3. 마이그레이션 진행하기

- 타입스크립트 개발 환경 설정, 빌드 파이프라인에 타입스크립트 컴파일러를 통합함
  - tsconfig.json 파일에서 `allowJS: true, noImplicityAny: false`로 설정
  - allowJs: 자바스크립트 파일을 컴파일할 때 사용하는 옵션
- 작성된 자바스크립트 파일을 타입스크립트 파일로 변환
  - 필요한 타입과 인터페이스를 하나씩 정의하며 함수 시그니처를 추가해나감
- 기존 자바스크립트 파일을 모두 타입스크립트로 변환하는 작업이 완료되면 `allowJs: false, noImplicityAny: true`로 변경 후 타입이 명시되지 않은 부분이 없는지 점검

## 12.4 모노레포

### 1. 분산된 구조의 문제점

- 각각의 레포지토리에서 해당 프로젝트를 위한 Jest, 바벨, ESlint, 타입스크립트 등의 설정 파일을 별도로 구성하고 빌드 파이프라인, 공통적인 컴포넌트, 소스코드를 독립적으로 관리
- 만약 프로젝트에 필요한 기능이 다른 프로젝트에 존재하면 복붙으로 구현 가능
- 여러 프로젝트에 동일한 코드를 복사하여 붙여 넣은 후에 새로운 버그가 발견되면 프로젝트의 개수만큼 반복 수정 작업을 해야 함
- 특정 라이브러리에 문제가 생기거나 더 이상 사용되지 않는 경우에도 모든 프로젝트에 일일이 대응해야 함
- 개발자는 변경이 필요한 지점을 모두 인지하고 있어야 하기 때문에 개발자 경험(DX)가 저하될 수 있음
- 장기적으로도 프로젝트 관리가 어려워지면서 업무 효율이 갈수록 악화될 수 있음
- 분산된 구조는 생산성을 떨어뜨리는 결과를 초래할 수 있으며 반복되는 코드를 함수화하여 통합하듯이 한 곳에서 프로젝트를 관리할 수 있도록 통합해야 함

### 2. 통합할 수 있는 요소 찾기

- 프로젝트 내에서 공통으로 통합할 수 있는 요소를 찾아야 함

### 3. 공통 모듈화로 관리하기

- 모듈화를 통해 통합할 수 있음
- npm과 같은 패키지 관리자를 활용하여 공통 모듈을 생성하고 관리하면 간편하게 모듈과 의존성을 맺고 사용할 수 있음
- 새로운 프로젝트를 시작하더라도 모듈을 토앻 코드를 재사용할 수 있으며, 특정 기능의 변경이 필요할 때는 해당 모듈의 소스코드만 수정하면 되기때문에 유지보수도 쉬움
- 아쉬운 점
  - 공통모듈에 변경이 발생한다면 해당 모듈을 사용하는 프로젝트에서도 추가 작업이 필요할 수 있음
  - 공통 모듈의 개수가 늘어나면 관리해야 할 레포지토리도 그만큼 늘어남
  - 새로운 공통 모듈이 필요하면 새로운 레포지토리를 생성하고 개발 환경을 설정하며 패키지 관리자를 사용하여 모듈을 게시해야 함
  - 새로운 프로젝트를 시작할 때도 빌드를 위한 CI/CD 파이프라인, Lint, 테스트 등도 별도로 설정해야 함

### 4. 모노레포의 탄생

- 모노레포: 버전 관리 시스템에서 여러 프로젝트를 하나의 레포지토리로 통합하여 관리하는 소프트웨어 개발 전략
- 모놀리식 기법: 다양한 기능을 가진 프로젝트를 하나의 레포지토리로 관리하는 방식, 이전에 사용
- 모놀리식 구조는 코드 간의 직접적인 의존이 발생하여 일부 로직만 변경될 때도 전체 프로젝트에 영향을 줄 수 있음
  - 설계적인 측면과 빌드 및 배포 등에서 효율적이지 못함
- 폴리레포: 작은 프로젝트의 집합으로 나누어 관리하는 방식
- 모노레포를 사용하면 개발 환경 설정도 통합할 수 있어서 더 효율적인 관리가 가능해짐
- 모노레포로 관리했을 때의 장점
  - 프로젝트마다 개별적인 레포지토리를 만드는 방식과 달리 Lint, CI/CD 등 개발 환경 설정도 통합적으로 관리하기 때문에 불필요한 코드 중복을 덜어줌
  - 개별적으로 프로젝트를 형성하는 폴리레포와는 다르게 공통 모듈도 동일한 프로젝트 내에서 관리되므로 별도의 패키지 관리자를 통해 모듈을 게시하지 않아도 됨
  - 이데 따라 기능 변화를 쉬벡 추적하고 의존성을 관리할 수 있게 됨
- 모노레포로 관리했을 때의 단점
  - 시간이 지나면서 레포지토리가 거대해질 수 있음
  - 하나의 레포지토리에 여러 팀의 이해관계가 얽혀있다면 소유권과 권한 관리가 복잡해질 수 있음
  - 각 프로젝트나 모듈의 소유권을 명확히 정의하고 규칙을 설정해야 하는 과정이 별도로 필요함
