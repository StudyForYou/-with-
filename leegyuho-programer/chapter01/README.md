> # 1.1 웹 개발의 역사

### 자바스크립트 표준, ECMAScript의 탄생

- 초기에 자바스크립트가 등장했을 때 `크로스 브라우징 이슈`가 있었는데 이는 웹 브라우저마다 자바스크립트를 해석하는 방식이 서로 다르기 때문에 발생
- 이런 문제를 해결하기 위해 `폴리필과 트랜스파일과 같은 개념이 등장`했으며 둘 다 최신 기능을 구버전의 실행 환경에서 동작할 수 있게 바꿔주는 역할을 함
- 언제까지 라이브러리에 기대어 크로스 브라우징 이슈를 해결할 수 없었기 때문에 `ECMAScript라는 이름으로 자바스크립트 표준화를 공식화`

<details>
<summary>💡 폴리필(polyfill)</summary>
브라우저가 지원하지 않는 코드를 브라우저에서 사용할 수 있도록 변환한 코드 조각이나 플러그인<br>
유명한 라이브러리로 core.js와 polyfill.io가 있다.
</details>
<details>
<summary>💡 트랜스파일(transpile)</summary>
최신 버전의 코드를 예전 버전의 코드로 변환하는 과정<br>
유명한 라이브러리로 babel이 있다.
</details>

### 웹사이트에서 웹 애플리케이션으로의 전환

- 웹사이트: 수집된 데이터 및 정보를 특정 페이징 표시하기 위한 정적인 웹 / `단방향`으로 정보를 제공하기 때문에 `사용자와 상호작용 X`
- 웹 애플리케이션: `사용자와 상호작용하는 쌍방향 소통의 웹`

### 개발 생태계의 발전

- 거대 웹 애플리케이션의 등장으로 `컴포넌트 단위로 개발하는 방식`이 생겨남
- Ajax로 페이지 전체를 새로고침하지 않아도 자바스크립트의 `비동기 요청`을 사용해서 페이지의 일부 데이터 로드가 가능해짐

<br>
<br>
<br>
<br>

> # 1.2 자바스크립트의 한계

### 동적 타입 언어

- 변수에 타입을 명시적으로 지정하지 않고 코드가 실행되는 런타임에 변숫값이 할당될 때 해당 값의 타입에 따라 변수 타입이 결정됨

### 동적 타이핑 시스템의 한계

```js
// 이 함수는 숫자 a, b의 합을 반환한다.
const sumNumber = (a, b) => {
  return a + b;
};

sumNumber(100); //NaN
sumNumber('a', 'b'); // ab
```

- 이 코드의 첫 번째 예시를 보면 인자에 하나의 숫자만 전달했지만 에러가 발생하지 않고 정상적으로 작동
- 두 수의 합을 구하기 위한 함수이지만 `개발자의 의도와 다르게` 문자열의 합을 구하는 데도 사용될 수 있다.

### 한계 극복을 위한해결 방안

- JSDoc: 모듈, 네임스페이스, 클래스, 메서드, 매개변수 등에 대한 API 문서 생성 도구로 타입 및 에러 확인이 가능 BUT `강제성을 부여해 사용하기 어려운 단점이 존재`
- propTypes: 리액트에서 컴포넌트 props의 타입을 검사하기 위해 사용하는 속성 BUT `전체 애플리케이션의 타입 검사에는 사용 X`, `리액트라는 특정 라이브러리에서만 사용 가능`
- 다트(Dart): 구글이 자바스크립트를 대체하기 위해 제시한 `새로운 언어`로 타이핑이 가능 BUT `개발의 파편화`를 불러올 수 있어 달갑지 않게 보는 시선이 강했음

### 타입스크리트의 등장

- 타입스크립트는 자바스크립트의 `슈퍼셋(Superset)`으로 점진적 도입이 가능
- `안정성 보장`
  - 컴파일 단계에서 타입 검사를 해주기 때문에 타입 에러가 줄어듬
  - 런타임 에러를 사전에 방지할 수 있어 안정성이 크게 높아짐
- `개발생산성 향상`
  - 타입 자동 완성 기능 제공
- `협업에 유리`
  - interface가 기술되면 코드를 더 쉽게 이해할 수 있게 도와준다.
