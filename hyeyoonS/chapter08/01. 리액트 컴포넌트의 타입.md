타입스크립트와 리액트를 결합하면 더 손쉽게 유지보수할 수 있는 애플리케이션을 개발할 수 있다. 리액트에서 사용하는 JSX 문법을 타입스크립트에 어떻게 적용하는지 살펴보장

# 리액트 컴포넌트의 타입

### 🤔언제 어떤 걸 쓰면 좋지?

## 1. 클래스 컴포넌트 타입

- 클래스 형태로 작성된 컴포넌트를 정의할 때 사용
- 기본적으로 클래스 컴포넌트가 상속받는 타입은 아래와 같다.

```tsx
//기본적으로 클래스 컴포넌트가 상속받는 타입 
interface Component<P = {}, S = {}, SS = any>
  extends ComponentLifecycle<P, S, SS> {} // P는 Props, S는 State를 의미함.

class Component<P, S> {
  /* ... 생략 */
}

class PureComponent<P = {}, S = {}, SS = any> extends Component<P, S, SS> {}
```

- 실제 활용 예시

```tsx
// Props의 타입 선언
interface WelcomeProps {
  name: string;
}

class Welcome extends React.Component<**WelcomeProps**> {
  /* ... 생략 */
}
```

- 상태가 있는 컴포넌트일 경우 제네릭의 `두 번째 인자`로 타입을 넘겨주면 상태에 대한 타입 지정 가능

```tsx
// Props의 타입 선언
interface WelcomeProps {
  name: string;
}

// State의 타입 선언
interface WelcomeState {
  message: string;
}

class Welcome extends React.Component<**WelcomeProps**, **WelcomeState**> {
  state: WelcomeState = {
    message: 'Welcome to React!',
  };

  render() {
    return <div>{this.state.message}, {this.props.name}!</div>;
  }
}
```

## 2. 함수 컴포넌트 타입

- 리액트에서 함수 컴포넌트의 타입 지정을 위해 제공되는 타입
- (구) children props가 필요한 경우 : React.FC
(구) children props가 필요하지 않은 경우 : React.VFC
- ⇒ (신) children props 필요 여부와 상관 없이 React.FC 사용
    - (cf. FC: Function Component의 약자)

```tsx
const Welcome: React.FC<WelcomeProps> = ({ name }) => {};
```

## 3. Children props 타입 지정

- 가장 보편적인 children 타입: ReactNode | undefined
    - ReactNode : ReactElement, boolean, number 등의 타입 포함
        - 구체적으로 타입을 지정 하는 데에는 적합하지 않음 ⇒ 추가 지정 필요

```tsx
// example 1 : 특정 문자열만 허용하고 싶을 때
type WelcomeProps = {
  children: "천생연분" | "더 귀한 분" | "귀한 분" | "고마운 분"; 
};

// example 2 : 문자열만 허용하고 싶을 때 
type WelcomeProps = { children: string };

// example 3 : JSX로 작성된 컴포넌트만 허용하고 싶을 때 
type WelcomeProps = { children: ReactElement };
```

## 4. Render메소드와 함수 컴포넌트의 반환 타입

### 1) render메소드의 반환타입 : JSX.Element | null

- 주로 React 클래스 컴포넌트에서 사용

```tsx
class MyComponent extends React.Component<Props, State> {
  render(): JSX.Element | null {
    return (
      <div>
        {/* 컴포넌트 */}
      </div>
    );
  }
```

### 2) 함수 컴포넌트 의 반환타입: JSX.Element

- 아무것도 반환하지 않는 경우는 반환 타입으로 void 사용

```tsx
const MyFunctionalComponent: React.FC<Props> = (props: Props) => {
  return (
    <div>
      {/* 컴포넌트 */}
    </div>
  );
}
```

<aside>
💡 **JSX가 뭐지?**
JSX는 자바스크립트의 확장 문법으로 리액트에서 UI를 표현하는 데 사용된다. 
JavaScript와 HTML을 조합한 문법을 사용하여 React 요소를 생성한다.

⇒ 즉, JSX는 리액트 엘리먼트를 생성하기 위한 문법이며 **트랜스파일러는 JSX 문법을 createElement 메서드 호출문으로 변환하여 리액트 엘리먼트를 생성한다.**

</aside>

⇒ JSX 코드를 작성하면 해당 코드는 JSX.Element로 변환되고, 이는 React 애플리케이션에서 React.ReactElement로 변환된다.
React.ReactNode은 React 애플리케이션에서 렌더링 가능한 모든 요소를 포함하는 범용적인 개념이며, JSX.Element는 TypeScript에서 JSX 요소의 타입을 정의하기 위해 사용된다. 

![300238639-ab9b7a8e-f583-4e70-8e1c-52e36b7ed161](https://github.com/StudyForYou/ouahhan-typescript-with-react/assets/144667455/1feffd90-4f3e-427b-a1ee-883918d7d08b)

### React.ReactElement가 뭐지?

- JSX를 통해 작성된 코드는 React.ReactElement로 변환된다.
- ReactElement 타입은 JSX의 createElement 메서드 호출로 생성된 리액트 엘리먼트를 나타내는 타입

⇒ 리액트 컴포넌트를 객체 형태로 저장하기 위한 포맷

```tsx
interface ReactElement<
  P = any,
  T extends string | JSXElementConstructor<any> =
    | string
    | JSXElementConstructor<any>
> {
  type: T;
  props: P;
  key: Key | null;
}
```

```tsx
const MyComponent: React.FC = (): React.ReactElement => {
  return <div>Hello World</div>;
};
```

### 언제 쓰지?

- JSX.Element에서 props타입이 any일 경우 ⇒ ReactElement를 사용해서 제네릭에 직접 props타입을 명시할 수 있다

```tsx
interface IconProps {
  size: number;
}

interface Props {
  // Item 컴포넌트의 props를 정의.
  // ReactElement의 props 타입으로 IconProps 타입 지정
  icon: React.ReactElement<IconProps>; // icon의 props의 타입은 IconProps
  // icon은 IconProps 타입의 props를 갖는 ReactElement임을 명시.
}

const Item = ({ icon }: Props) => {
  //icon을 props로 받음
  // icon prop으로 받은 컴포넌트의 props에 접근하면, props의 목록이 추론된다
  const iconSize = icon.props.size; // icon의 props에 접근.

  return <li>{icon}</li>;
};
```

### JSX.Element가 뭐지?

⇒ 타입스크립트가 JSX를 사용할 때 정의하는 타입

- props와 타입 필드가 any 타입인 리액트 엘리먼트

### 언제 쓰지?

- 리액트 엘리먼트를 prop으로 전달받아 render props패턴으로 컴포넌트를 구현할 때

```tsx
// JSX.Element 타입을 사용하여 React 컴포넌트에서 자식 컴포넌트를 props로 전달하고,
// 그 자식 컴포넌트의 props에 접근하는 방법

//IconProps을 JSX.Element 타입으로 선언함으로써 해당 prop에는 JSX 문법만 삽입할 수 있다.
interface IconProps {
  icon: JSX.Element;
}

const Item = ({ icon }: IconProps) => {
  // icon을 prop으로 받음.
  // prop으로 받은 컴포넌트의 Iconprops에 접근할 수 있다
  const iconSize = icon.Iconprops.size; // icon의 props에 접근하여 size 속성을 가져옴.
  // icon이 JSX 요소이기 때문에 가능함.

  return <li>{icon}</li>;
};

// icon prop에는 JSX.Element 타입을 가진 요소만 할당할 수 있다
const App = () => {
  return <Item icon={<Icon size={14} />} />; // Icon컴포넌트는 JSX.Element 타입의 요소
};
```

### React.ReactNode가 뭐지?

- JSX를 사용하여 작성된 모든 구조 요소

⇒ React 컴포넌트의 렌더링 결과물로 나오는 **모든 종류의 Node를 나타내는 타입**

⇒ 문자열, 숫자, 또는 ReactElement와 같은 JSX Element 등 다양한 종류의 값을 포함한다.

```tsx
type ReactFragment = {} | Iterable<ReactNode>; // ReactNode의 배열 형태
type ReactNode =
  | ReactChild
  | ReactFragment
  | ReactPortal
  | boolean
  | null
  | undefined;
```

### 언제 쓰지?

- JSX형태의 문법을 어떤 타입이든 children prop으로 지정할 수 있게 하고 싶다면 ReactNode 타입으로 children을 선언하면 된다.
- prop으로 리액트 컴포넌트가 다양한 형태를 가질 수 있게 하고 싶을 때
