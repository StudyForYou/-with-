# 타입 확장하기

## 타입 확장이란?

기존 타입을 사용해서 새로운 타입을 정의하는 것

### 🤔타입을 어떻게 쓰지?

`타입 정의`: Interface, type
`타입 확장`: extends 키워드, intersection 타입, 유니온 타입

## 타입 확장의 장점

- 중복 제거
- 명시적인 코드 작성 가능
- 확장성

interface에서의 타입 확장

- 하나의 인터페이스를 다른 인터페이스들이 상속받아 중복된 프로퍼티를 정의하지 않도록 도와주는 문법

```jsx
interface BaseMenuItem {
	itemName: string | null;
	itemImageUrl: string | null;
	itemDiscountAmount: number;
	stock: number | null;
};

interface BaseCartItem extends BaseMenuItem {
	quantity: number;
}
```

type에서의 타입 확장

```jsx
type BaseMenuItem = {
	itemName: string | null;
	itemImageUrl: string | null;
	itemDiscountAmount: number;
	stock: number | null;
};

type BaseCartItem = {
	quentity: number;
} & BaseMenuItem;
```

⇒ 기존 정보를 수정하지 않고 무한 바리에이션 가능!

### 유니온 타입

2개 이상의 타입을 조합하여 사용하는 방법.

합집합

```jsx
type MyUnion = A | B; //MyUnion의 타입은 A타입이면서 B타입이어야 한다. 
```

유니온 타입으로 선언된 값은 유니온 타입에 포함된 `모든 타입이 공통으로 가지고 있는 속성에만` 접근할 수 있다.

```jsx
interface CookingStep {
	orderId: string;
	price: number;
}

interface DeliveryStep {
	orderId: string;
	time: number;
	distance: string;
}

function getDeliveryDistance(step: CookingStep | DeliveryStep) {
	return step.distance; 	//distance는 DeliveryStep에만 존재하므로 에러 발생
}
```

```jsx
interface Person {
  name: string;
  age: number;
}
interface Developer {
  name: string;
  skill: string;
}
function introduce(someone: Person | Developer) {
  someone.name; // O 정상 동작
  someone.age; // X 타입 오류
  someone.skill; // X 타입 오류
}
```

### 교차(Intersection) 타입

기존 타입을 합쳐서 필요한 모든 기능을 가진 하나의 타입을 만드는 것 

여러 타입을 모두 만족하는 하나의 타입

교집합

```jsx
let variable: number & string; 
// never 타입으로 추론된다
```

```jsx
type MyIntersection = A & B;
```

```jsx
interface Person {
  name: string;
  age: number;
}
interface Developer {
  name: string;
  skill: number;
}

type Capt = Person & Developer;

/* Capt의 타입 */
{
  name: string;
  age: number;
  skill: string;
}
```

```jsx
type Dog = {
  name: string;
  color: string;
};

type Person = {
  name: string;
  language: string;
};

type Intersection = Dog & Person;

let intersection1: Intersection = {
  name: "",
  color: "",
  language: "",
};
```

교차 타입을 사용할 때 타입이 서로 호환되지 않는 경우가 있다. 

```jsx
type IdType = string | number;
type Numeric = number | boolean;

type Universal = IdType & Numeric; //Universal의 타입은 number이다
```

extends로 교차 타입을 만들 수 있다.

유니온 타입과 교차 타입을 사용한 새로운 타입은 오직 type 키워드로만 선언할 수 있다.

> extends키워드를 사용한 타입이 교차 타입과 100% 상응하지 않는다
> 

```jsx
interface DeliveryTip {
	tip: number;
}

interface Filter extends DeliveryTip {
	tip: string; //type error; Type 'string' is not assignable to type 'number'
}
```

```jsx
type DeliveryTip {
	tip: number;
}

type Filter = DeliveryTip & {
	tip: string;
}

// never 타입으로 추론된다.

```

type키워드는 교차 타입으로 선언되었을 때 새롭게 추가되는 속성에 대해 미리 알 수 없기 때문에 선언 시에 에러가 발생하지 않는다. 하지만 tip이라는 같은 속성에 대해 서로 호환되지 않는 타입이 선언되어 결국 never 타입이 된 것이다.
