# 4장. 타입 확장하기, 좁히기

- 타입 확장하기: 기존에 정의한 타입을 이용하여 새로운 타입을 정의
- 타입 좁히기: 어떤 대상에 대한 타입 추론을 더 작은 범위로 좁힘

## 4-1. 타입 확장하기

### 1. 타입 확장의 장점
- 중복 코드 제거, 명시적인 코드 작성, 확장성

### 2. 유니온 타입
```ts
type unionType = A | B;
/**
 * 💡 유니온 타입은 합집합 같은 개념으로, 유니온 타입에는 변수가 더 쉽게 할당될 수 있다.
 * 대신 변수가 유니온 타입의 특정 타입이라고 단정할 수는 없기에 변수에서 속성 값을 꺼내기는 어려워진다.
 * 💡 집합 개념을 이해할 때 "이 값이 이 집합(타입)의 원소인가" 질문을 했을 때 맞는지와,
 *  "이 객체가 특정 타입의 인스턴스로서 작동할 수 있는가?(=필요한 프로퍼티, 메서드를 갖고 있는가)" 를 통해 값이 타입에 속하는지를 파악하면 좋다.
 */
/**
 * 💡 집합 개념을 이해할 때 "이 값이 이 집합(타입)의 원소인가" 질문을 했을 때 맞는지와,
 "이 객체가 특정 타입의 인스턴스로서 작동할 수 있는가?(=필요한 프로퍼티, 메서드를 갖고 있는가)" 를 통해 값이 타입에 속하는지를 파악하면 좋다.
 */
```

### 3. 교차 타입
```ts
type intersectionType = A & B;
/**
 * 💡 교차 타입은 교집합 같은 개념으로, 교차 타입에는 A, B의 속성을 모두 가진 변수가 할당될 수 있기 때문에 할당이 어렵다.
 * 대신 변수가 A, B 타입에 둘 다 속하기 때문에 변수에서 속성 값을 꺼내기는 쉬워진다.
 */
```

### 4. extends와 교차 타입
- 교집합 개념의 타입을 정의할 때
  - type 키워드는 &을 사용,
  - interface 키워드는 extends를 사용한다.
- 이 때 extends와 &는 일부 차이가 있다.

```ts
// 1. interface와 extends를 사용할 때
interface DeliveryTip {
  tip: number;
}

// 🚨 자식(Filter)에 부모(DeliveryTip)과 호환되지 않는 속성을 선언하면 에러 발생
interface Filter extends DeliveryTip {
  tip: string;
}

// 2. type과 &를 사용할 때
type DeliveryTip = {
  tip: number;
}

// ✅ 에러가 발생하지는 않는다. 이 때 자식은 never 타입이 된다.
type Filter = DeliveryTip & {tip: string};
```

### 👣 활용하기
일반적인 메뉴 타입이 존재하는데, 요구사하아이 추가되어 특정 메뉴의 속성의 변화가 일어났을 때
```ts
interface Menu {
  name: string;
  image: string;
}

interface SpecialMenu extends Menu {
  gif: string;
}

interface PackageMenu extends Menu {
  text: string;
}
```
💡 이렇게 하나의 타입에 여러 속성을 추가하는 것보다, 확장 타입을 새로 선언하면 해당 타입을 보다 안전하게 사용할 수 있다. 앞으로 props에 무작정 속성을 추가하기 보다, 확장 타입으로 기존 타입과 분리할 수 있는지를 계속 생각해보자.
