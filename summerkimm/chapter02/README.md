# 타입
## 2.1 타입이란
### 1. 자료형으로서의 타입
#### 자바스크립트의 7가지 데이터 타입(자료형)
>데이터 타입 : 여러 종류의 데이터를 식별하는 분류 체계, 컴파일러에 값의 형태를 알려줌 
- undefined
- null
- Boolean(불리언)
- String(문자열)
- Symbol(심볼)
- Numeric(Number와 BigInt)
- Object 

### 2. 집합으로서의 타입
#### 값이 가질 수 있는 유효한 범위의 집합 
타입 시스템은 코드에서 사용되는 유효한 값의 범위를 제한해서 런타임에서 발생할 수 있는 유효하지 않은 값에 대한 에러를 방지함. 

### 3. 정적 타입과 동적 타입

**타입을 결정하는 시점**에 따라 정적 타입과 동적 타입으로 나뉨.
- **정적 타입 시스템** : 모든 변수의 타입이 **컴파일타입**에 결정됨 (ex. 타입스크립트) 
  - 컴파일 타임에 타입 에러를 발견할 수 있기 떄문에 프로그램의 안정성을 보장함. 
- **동적 타입 시스템** : 변수 타입이 **런타임**에서 결정됨 (ex. 자바스크립트)
  - 개발 과정에서 자유롭게 코드 작성이 가능하지만, 오류를 예측하기 어려움.

> 컴파일타임 : 기계(컴퓨터, 엔진)가 소스코드를 이해할 수 있도록 기계어로 변환되는 시점   
> 런타임 : 변환된 파일이 메모리에 적재되어 실행되는 시점

### 4. 강타입과 약타입
**암묵적 타입 변환 여부**에 따라 타입 시스템을 **강타입**과 **약타입**으로 나뉨 

- **강타입** : 서로 다른 타입을 갖는 값끼리 연산을 시도하면 컴파일러 또는 인터프리터에서 에러 발생 (ex. 타입스크립트)
- **약타입** : 서로 다른 타입을 갖는 값끼리 연산할 때 컴파일러 또는 인터프리터가 내부적으로 판단해서 특정 값의 타입을 변환하여 연산을 수행한 후 값을 도출함 (ex. 자바스크립트)   -> **암묵적 (타입) 변환**   

**암묵적 변환** 의 특징    
- 장점 : 개발자가 명시적으로 타입을 변환하지 않아도 다른 데이터 타입끼리 연산을 제공할 수 있는 편리함 제공
- 단점 : 작성자의 의도와 다르게 동작할 수 있기 때문에 오류 발생 가능성 큼.

**타입 시스템** : 타입 검사기가 프로그램에 타입을 할당하는 데 사용하는 규칙 집합, 아래와 같이 나뉨
  1. 어떤 타입을 사용하는지를 컴파일러에 명시적으로 알려줘야 하는 타입 시스템
  2. 자동으로 타입을 추론하는 타입 시스템    

**타입스크립트는 두 가지 타입 시스템의 영향을 모두 받음**   

### 5. 컴파일 방식
**일반적인 컴파일** : 사람이 이해할 수 있는 방식으로 작성한 코드를 컴퓨터가 이해할 수 있는 기계어로 바꿔주는 과정

**타입스크립트의 컴파일** : 자바스크립트의 컴파일타임에 런타임 에러를 사전에 잡아내기 위한 것 (결과물: 자바스크립트)

## 2.2 타입스크립트의 타입 시스템
### 1. 타입 애너테이션 방식
> 타입 애너테이션 : 변수나 상수 혹은 함수의 인자와 반환 값에 타입을 명시적으로 선언해서 어떤 타임 값이 저장될 것인지를 컴파일러에 직접 알려주는 문법   
#### 타입스크립트의 타입 선언 방식
변수 이름 뒤에 `: type` 구문을 붙여 데이터 타입 명시함.

### 2. 구조적 타이핑
타입스크립트에서 타입을 구분하는 방식 : 구조적 타이핑 <-> 명목적 타이핑 (타입의 이름만을 가지고 구별함)
### 3. 구조적 서브타이핑
#### 객체가 가지고 있는 속성(프로퍼티)을 바탕으로 타입을 구분하는 것   
이름이 다른 객체라도 가진 속성이 동일하다면 타입스크립트는 서로 호환이 가능한 동일한 타입으로 여김. 
  ```ts
  interface pet {
    name: string;
  }

  interface Cat {
    name: string;
    age: number;
  }

  let pet: Pet;
  let cat: Cat = { name: "Zag", age: 2 };

  pet = cat; // Ok!
  ```
  함수의 매개변수에도 적용됨 
  ```ts
  interface Pet {
    name: string;
  }
  let cat = { name: "Zag", age: 2 };
  function greet(pet: Pet) {
    console.log("Hello, " + pet.name);
  } 

  greet(cat); // Ok!
  ```
  타입을 명시하지 않은 cat 객체를 greet() 함수의 인자로 전달 가능함.   
  -> cat 객체는 Pet 인터페이스가 가지고 있는 name 속성을 갖고 있어 pet.name의 방식으로 name 속성에 접근 가능하기 때문  

  ```ts
  class Person {
    name: string;
    age: number;
  
    constructor(name: string, age: number) {
      this.name = name;
      this.age = age;
    }
  }

  class Developer {
    name: string;
    age: number;
    sleepTime: number;

    constructor(name: string, age: number, sleepTime: number) {
      this.name = name;
      this.age = age;
      this.sleepTime = sleepTime;
    }
  }

  function greet(p: Person) {
    console.log(`Hello, I'm ${p.name}`);
  }

  const developer = new Developer("zig", 20, 7);

  greet(developer); // Hello, I'm zig
  ```
  Developer 클래스가 Person 클래스를 상속받지 않음에도 greet(developer) 오류 X    
  -> Developer 클래스가 Person이 갖고 있는 속성을 가지고 있기 떄문


### 4. 자바스크립트를 닮은 타입스크립트  
타입스크립트가 명목적 타이핑이 아닌 **구조적 타이핑**을 채택한 이유   
: 타입스크립트는 **덕 타이핑**을 기반으로 한 자바스크립트를 모델링한 언어
>덕 타이핑 : 어떤 타입에 부합하는 변수와 메서드를 가질 경우 해당 타입에 속하는 것으로 간주하는 방식 

#### 덕 타이핑 vs 구조적 타이핑
- 공통점 : 객체 변수, 메서드 같은 필드를 기반으로 타입을 검사함
- 차이점 : 타입을 검사하는 시점이 다름
  - 덕 타이핑 : 동적 타이핑(런타임)에 타입 검사
  - 구조적 타이핑 : 정적 타이핑(컴파일타임)에 타입 검사 

### 5. 구조적 타이핑의 결과 
특정 타입 값이 들어갈 곳에 추가 속성을 가진 객체도 할당할 수 있기 때문에 오류 발생 가능성 큼 -> 해결 방안 : 유니온(명목적 타이핑 언어의 특징)

### 6. 타입스크립트의 점진적 타입 확인 
> 점진적 타입 검사 : 컴파일 타임에 타입을 검사하면서 필요에 따라 타입 선언 생략을 허용하는 방식    

타입을 지정한 변수와 표현식은 정적으로 타입 검사,   
타입 선언이 생략되면 동적으로 타입 검사(=암시적 타입 변환: any 타입으로 추론)
  > any 타입 : 타입 스크립트 내 모든 타입의 종류를 포함하는 가장 상위 타입, 어떤 타입 값이든 할당 가능함   
  (타입스크립트 컴파일 옵션인 noImplicitAny 값이 true일 때는 에러 발생)


### 7. 자바스크립트 슈퍼셋으로서의 타입스크립트
모든 자바스크립트 코드는 타입스크립트 코드이다.   
그러나, 모든 타입스크립트 코드는 자바스크립트 코드가 아니다.   
-> 타입스크립트는 타입을 명시하는 문법을 가지고 있기 떄문 

### 8. 값 vs 타입
타입스크립트에서 값으로 사용 : 컴파일을 거쳐도 여전히 자바스크립트 파일에 해당 정보가 남아 있음   
타입으로만 사용 : 컴파일 이후에 자바스크립트 파일에서 해당 정보가 사라짐   
클래스와 enum은 두 가지 모두 가능함 

### 9. 타입을 확인하는 방법 
<!-- 추가 수정 필요 -->
1. typeof   
    - 연산하기 전에 피연산자의 데이터 타입을 나타내는 문자열을 반환함    
    - 반환값 : 자바스크립트의 7가지 기본 데이터 타입(Boolean, null, undefined, Number, BigInt, String, Symbol), Function(함수), 호스트 객체, object 객체
    - 값에서 사용된 typeof: 자바스크립트 런타임의 typeof 연산자가 됨   
    - 타입에서 사용된 typeof: 값을 읽고 타입스크립트의 타입을 반환함 
2. instanceof
3. 타입 단언 
## 2.3 원시 타입
자바스크립트의 7가지 원시 값은 타입스크립트에서 원시 타입으로 존재함 

타입스크립트의 모든 타입은 기본적으로 null과 undefined를 포함함.   
(tsconfig의 strictNullChecks 옵션으로 활용 가능함.)

### 1. boolean
오직 true와 false 값만 할당할 수 있는 boolean 타입 
(자바스크립트의 Truthy, Falsy 값은 boolean 원시 값이 아니므로 타입스크립트레서도 boolean 타입 해당 X)
### 2. undefined
정의되지 않았다는 의미의 타입   
오직 undefined 값만 할당 가능함    
변수 선언만 하고 값을 할당하지 않을 때 undefined가 반환됨    
### 3. null
오직 null만 할당 가능함. 
### 4. number
자바스크립트의 숫자에 해당하는 모든 원시 값을 할당 가능함 (NaN이나 Infinity도 포함)
### 5. bigInt
자바스크립트에서 가장 큰 수인 Number.MAX_SAFE_INTEGER(253-1)를 넘어가는 값   
number 타입과 상호작용 불가능
### 6. string
문자열을 할당할 수 있는 타입   
### 7. symbol
Symbol() 함수를 사용하면 어떤 값과도 중복되지 않는 유일한 값 생성 가능함. 
```ts
const MOVIE_TITLE = Symbol("title");
const MUSIC_TITLE = Symbol("title");
console.log(MOVIE_TITLE === MUSIC_TITLE); // false

```
## 2.4 객체 타입 
7가지 원시 타입에 속하지 않는 값은 모두 객체 타입으로 분류함 

### 1. object
object 타입은 사용 지양 권장   
  -> 이유 : 객체에 해당하는 모든 타입 값을 유동적으로 할당할 수 있어 정적 타이핑의 의미가 크게 퇴색됨.    

### 2. {}
- 중괄호 안에 객체의 속성 타입을 지정할 때 사용됨
- 빈 객체의 타입을 나타낼 때 {} 사용 가능    
(but, {} 보다 유틸리티 타입으로 Record<string, never>이 바람직한 사용)

### 3. array
타입스크립트에서는 배열은 array 타입을 지정해, 하나의 타입 값만 갖게 함.   
단, 원소 개수는 타입에 영향을 주지 않음.   

타입스크립트에서 배열 타입 선언 방식
1. Array 키워드로 선언
2. 대괄호([])를 사용해 선언 (튜플 타입과 혼동 주의!)

### 4. type과 interface 키워드
object나 array보다 type이나 interface를 자주 사용함 

#### 타입스크립트에서는 모든 변수에 타입을 일일이 명시적으로 선언할 필요 X   
-> 타입스크립트 컴파일러가 변수 사용 방식과 할당된 값의 타입을 분석해서 자동으로 타입을 추론하기 때문 

### 5. function 
타입스크립트에서도 함수를 별도 함수 타입으로 지정 가능함   
주의점   
1. 자바스크립트에서 typeof 연산자로 확인한 function이라는 키워드 자체를 타입으로 사용하지 않는다.
2. 매개변수도 별도 타입으로 지정해야 함 

  매개변수와 반환 값에 대한 타입 지정 
  ```ts
  function add(a: number, b: number): number {
    return a + b;
  }
  ```

  함수 자체의 타입 지정 : 호출 시그니처 사용    
  - 호출 시그니처 : 함수 타입은 해당 함수가 받는 매개 변수와 반환하는 값의 타입으로 결정되는데, 이러한 함수의 매개변수와 반환 값의 타입을 명시하는 역할을 함. 
  ```ts
  type add = (a: number, b: number) => number;
  ```
